



### 函数重载(overload function)

#### 函数重载的概念：

##### 概念：

当函数具有相同的名称，但是参数列表不相同的情形（包括参数的个数不同或参数的类型不同），这样的同名而不同参数的函数之间，互相被称之为重载函数。

##### 基本条件：

- 函数名必须相同；
- 函数参数必须不相同，可以是参数类型或者参数个数不同；
- 函数返回值可以相同，也可以不相同。（备注：但是如果函数的名称和参数完全相同，仅仅是返回值类型不同，是无法进行函数重载的。）

##### 注意：

- 只能通过不同的参数样式进行重载，例如：不同的参数类型，不同的参数个数，或者不同的参数顺序；
- 不能通过访问权限、返回类型、抛出的异常不同而进行重载；
- 重载的函数应该在相同的作用域下。

##### 函数重载实例判断：

以下的集中写法，分别表示了哪些是重载的，哪些不是重载的。
(1) void func1( int arg1);
(2) void func1( double arg1);
(3) void func1( int arg1, int arg2);
(4) bool func1(int arg1, double arg2)
(5) int func1(int arg1);

在上述的5个函数中，函数名称都是func1，完全相同；但是：
(2)与(1)的参数个数相同，参数类型不同，构成重载；
(3)与(1)和(2)的参数个数不同，构成重载；
(4)与(1)和(2)的参数个数不同，与(3)的参数个数相同，但是第二个参数类型不同，构成重载；
(5)与(1)的参数个数和参数类型均相同，仅返回值的类型不相同，不构成重载；但是(5)与(2),(3)和(4)除返回值不同外，均有参数类型或参数个数不同的情况，因此构成重载关系。

### 函数重写（override function）

虽然与函数重载仅仅只有一个字的差别，但是这两个概念却是相差了很远很远。它俩似乎一点关系都没有。也正因为如此，这个非常考验C++语言的基本功，也是历年C++笔试中经常会出现的考题。

#### 函数重写(override function)

##### 概念：

函数重写，也被称为覆盖，是指子类重新定义父类中有相同名称和参数的虚函数，主要在继承关系中出现。

##### 基本条件：

- 重写的函数和被重写的函数必须都为virtual函数，并分别位于基类和派生类中；
- 重写的函数和被重写的函数，函数名和函数参数必须完全一致；
- 重写的函数和被重写的函数，返回值相同，或者返回指针或引用，并且派生类虚函数返回的指针或引用的类型是基类中被替换的虚函数返回的指针或引用的类型的字类型。





### 函数重载（overload）

函数重载是指在一个类中声明多个名称相同但参数列表不同的函数，这些的参数可能个数或顺序，类型不同，但是不能靠返回类型来判断。特征是：
（1）相同的范围（在同一个作用域中）；
（2）函数名字相同；
（3）参数不同；
（4）virtual 关键字可有可无（注：函数重载与有无virtual修饰无关）；
（5）返回值可以不同；

###  函数重写（也称为覆盖 override）

函数重写是指子类重新定义基类的虚函数。特征是：

（1）不在同一个作用域（分别位于派生类与基类）；
（2）函数名字相同；
（3）参数相同；
（4）基类函数必须有 virtual 关键字，不能有 static 。
（5）返回值相同，否则报错；
（6）重写函数的访问修饰符可以不同；

重载与覆盖的区别：

(1)覆盖是子类和父类之间的关系，是垂直关系；重载是同一个类中不同方法之间的关系，是水平关系；

(2)覆盖要求参数列表相同，重载要求参数列表不同；覆盖要求返回类型相同，重载则不要求；

(3)覆盖关系中，调用方法体是根据对象的类型（基类类型还是派生类类型）来决定的，重载关系是根据调用时的实参表与形参表来选择方法体的。

###  重定义（也称隐藏）

（1）不在同一个作用域（分别位于派生类与基类） ；
（2）函数名字相同；
（3）返回值可以不同；
（4）参数不同。此时，不论有无 virtual 关键字，基类的函数将被隐藏（注意别与重载以及覆盖混淆）；

（5）参数相同，但是基类函数没有 virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）；

```c++
#include <iostream>
using namespace std;
 
class Base
{
public:
	void a()
	{
		cout << "void Base::a()" << endl;
	}
	//重载了上面的void a()函数,发生在同一个类中
	void a(int i)
	{
		cout << "void Base::a(int i)" << endl;
	}
	virtual void b()
	{
		cout << "virtual void Base::b()" << endl;
	}
	virtual void c()
	{
		cout << "virtual void Base::c()" << endl;
	}
	virtual void d()
	{
		cout << "virtual void Base::d()" << endl;
	}
private:
	int x;
};
class Derived :public Base {
public:
	//在基类Base中，函数a不是虚函数，所以这里是重定义
	void a()
	{
		cout << "void Derived::a()" << endl;
	}
	//参数不同。此时，不论无论有无virtual 关键字，基类的函数将被隐藏，属于重定义
	void b(float f)
	{
		cout << "virtual void Derived::b(float f)" << endl;
	}
	/*
	//编译器报错，也就是说编译器认为函数名和参数都与基类的虚函数c相同，那么返回值也必须相同
	//要么，你就别让编译期认为这是多态，也就是别和基类设置一样的函数名或参数，改变其一即可
	float c()
	{
		cout << "virtual float Derived::c()" << endl;
		return 1.1;
	}
	*/
	//父类中定义了虚函数，子类与父类函数名字相同，参数相同，返回值相同，属于函数重写
	void d()
	{
		cout << "virtual void Derived::d()" << endl;
	}
};
int main()
{
	int i = 6;
	float f = 'a';
	Base base;
	base.a();
	base.a(i);
	base.b();
	base.c();
	base.d();
	Derived derived;
	derived.a();
	derived.b(f);
	derived.d();
	return 0;
}
```

